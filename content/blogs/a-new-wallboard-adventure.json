{
  "date": "2020-08-11T12:50:11.029Z",
  "title": "A new wallboard adventure!",
  "body": "During a conversation with our lead front end dev, we got chatting about what new technologies he was using on up-and-coming projects. One of those technologies was [VueJS](vuejs.org). VueJS is a progressive javascript framework for building snappy/responsive UI's and single page applications. I was intrigued, and set about researching this.\n\nFront-End development is one of my hobbies, that I generally don't get to do during my day-to-day job (being a back-end developer, and all!). I needed a project to work on in my own time to work towards. One thing that drew me to Vue, is the fact that each component can contain the template, the script and the css.. making it truly self-contained. I'm not sure at the moment how I feel about having the CSS embedded into the component, but it's nice to know it's available.\n\nEnter Wallboard v2. \n\nI'd previously developed a wallboard for a previous company, so I figured I could do something like that with Vue.\n\nWe have a multitude of different things that could potentially be deplayed here, such as current builds, pull requests etc. We also monitor our live sites with Pingdom. Perfect.\n\n\\\nOur Source control of choice is BitBucket, so after researching the BB Api, I figured that I could use that to get some of the information I wanted. Pingdom also has an API you can use for their services!\n\nUpon realising that both BitBucket and Pingdom supported WebHooks, this gave me an idea to use those, as I'd not done anything with those before. The previous iteration of the wallboard polled an endpoint every x minutes.. not really that efficient. WebHooks push data to you, when it's needed.\n\nBoth Bitbucket and Pingdom have the ability to send a WebHook notification to an endpoint when something of interest happens, so I broke out my favourite editor (Visual Studio), and started planning what my endpoint services were to do.\n\nI created a .Net Core 2.0 application that would server as the intermediary between the messages from BitBucket and Pingdom, and my Front-End view (get it?!).\n\nThis contained various controller endpoints that would accept the object from BB and Pingdom, then push it out via a WebSocket to any listening devices.\n\nFor instance:\n\n```\n        /// <summary>\n        /// Created Pull Request\n        /// </summary>\n        /// <param name=\"pullRequest\"></param>\n        /// <returns></returns>\n        [HttpPost]\n        [SwaggerOperation(\"Created Pull Request\")]\n        [Route(\"CreatePullRequest\")]\n        public IActionResult CreatePullRequest([FromBody]object pullRequest)\n        {\n            CreateWebSocketResponse(\"PullRequestCreated\", pullRequest);\n\n            return Ok();\n        }\n```\n\nThe *CreatePullRequest* endpoint was specified in BitBucket as a webhook, so that when a pull-request was created from a developer for peer-review / code-merge, this would fire.\n\nThis in turn would call\n\n```\n        private void CreateWebSocketResponse(string action, object pullRequest)\n        {\n            WebSocketResponse wsr = new WebSocketResponse();\n\n            wsr.Event = action;\n            wsr.Payload = pullRequest;            \n\n            string retJson = JsonConvert.SerializeObject(wsr);\n            serv.SendMessageToAllAsync(retJson);\n        }\n```\n\n Unfortunately, for webhooks to work properly, they need to be on a publicly-accessible. So a quick publish to Azure on their free tier for testing purposes, and away we go!\n\nUsing either the Swagger documentation (that I use for all my Web API needs), or the ever-trusty Postman app, I can begin faking some responses before I plug it all in to the relevant services.\n\nA few more tweaks, and a few more endpoints created, and the back-end is done.\n\nOnto the part that I was actually wanting to do! - The Front End with Vue.\\\n(Now, granted, this might not be the greatest vue layout, but I'm still learning this!)\n\n## Vue\n\n```\n<template>\n  <div id=\"app\">\n      <div class=\"grid-container\">\n\n          <div class=\"grid-x grid-margin-x grid-margin-y\">\n              <div class=\"cell large-12 header\">\n                  Logo <Clock />\n              </div>\n          </div>\n\n          <div class=\"grid-x grid-margin-x grid-margin-y\">\n             <div class=\"cell large-6\">\n                <Bitbucket webhook=\"ws://codeurl.azurewebsites.net/ws\" />\n             </div>\n\n              <div class=\"cell large-6  \">\n                  <Dynatrace webhook=\"ws://codeurl.azurewebsites.net/ws\" />                  \n              </div>              \n          </div>\n\n          <div class=\"grid-x grid-margin-x grid-margin-y\">\n              <div class=\"cell large-6\">\n                  <VSTS webhook=\"ws://codeurl.azurewebsites.net/ws\" />\n              </div>\n          </div>\n\n          <Pingdom webhook=\"ws://codeurl.azurewebsites.net/ws\" />\n      </div>     \n  </div>\n</template>\n\n<script>\n\n    import VSTS from './components/VSTS.vue'\n    import Pingdom from './components/Pingdom.vue'\n    import Clock from './components/Clock.vue'\n    import Bitbucket from './components/Bitbucket.vue'\n    import Dynatrace from './components/Dynatrace.vue'\n\nexport default {\n  name: 'app',\n  components: {\n      VSTS,\n      Pingdom,\n      Clock,\n      Bitbucket,\n      Dynatrace\n  }\n}\n</script>\n\n<style>\n    body, html {\n        height: 100%;\n        overflow: hidden;\n    }\n\n    body {\n        background: #222426; /* Old browsers */\n        background: -moz-linear-gradient(top, #222426 0%, #000000 100%); /* FF3.6-15 */\n        background: -webkit-linear-gradient(top, #222426 0%,#000000 100%); /* Chrome10-25,Safari5.1-6 */\n        background: linear-gradient(to bottom, #222426 0%,#000000 100%); /* W3C, IE10+, FF16+, Chrome26+, Opera12+, Safari7+ */\n        filter: progid:DXImageTransform.Microsoft.gradient( startColorstr='#222426', endColorstr='#000000',GradientType=0 ); /* IE6-9 */\n        color: #a0a0a0;\n    }\n\n    #app {\n\n    }\n\n        #app .grid-container {\n\n        }\n\n        .header {\n            border-bottom: 1px solid #a0a0a0;\n            color: #a0a0a0;\n            font-size: 30px;\n        }\n\n\n        .sidebar {\n            border-right: 1px solid #a0a0a0;            \n        }\n</style>\n```\n\nAs you can see, I have a few Components that will do the actual listening for the websocket data.\n\nThe code for the Bitbucket component, looks like this:\n\n```\n<template>\n    <div class=\"\" v-bind:class=\"{'align-center align-middle': bitbucketlist.length == 0 }\">\n        \n        <div v-if=\"bitbucketlist.length == 0\">\n            <div class=\"nocontent\">\n                <h1>{{ nodata }}</h1>\n            </div>\n        </div>\n\n        <div v-if=\"bitbucketlist.length > 0\" class=\"pull-request-overview\">\n            <span id=\"count\">15</span>\n            Open Pull requests\n        </div>\n\n\n        \n        <div v-for=\"item in bitbucketlist\" class=\"cell large-4 pull-request\" v-bind:id=\"item.check_id\" v-bind:key=\"item.check_id\">\n            <h3>{{ item.pullrequest.description}} </h3> \n            <span class=\"source\">{{ item.pullrequest.source.branch.name}}</span> to \n            <span class=\"dest\">{{ item.pullrequest.destination.branch.name }}</span>\n            <div class=\"author\">\n                <img v-bind:src=\"item.pullrequest.author.links.avatar.href\" width=\"50\" height=\"50\"/>\n                {{ item.pullrequest.author.display_name}}\n                \n            </div>\n        </div>\n        \n\n    </div>\n</template>\n\n<script>\n\n    var bitbucketlist = [];  \n    var $isModalVisible = false;\n    export default {\n        name: 'Bitbucket',        \n        methods: {\n\n        },\n        data: function () {\n            return {\n                nodata: \"Waiting for Pull Requests\",\n                bitbucketlist\n            }\n        },\n        props: {\n            webhook: String\n        },\n        created: function() {\n            //var uri = \"ws://codeurl.azurewebsites.net/ws\";\n            var socket = new FancyWebSocket(this.webhook);            \n            socket.bind('PullRequestCreated', function (data) {\n                \n                bitbucketlist.push(data);                \n                data = {};\n            });            \n        }\n    }\n</script>\n\n<style scoped>\n    .pull-request {\n        border: 1px solid red;\n    }\n</style>\n```\n\nIn the Created() method, it sets up the websocket, and binds the 'PullRequestCreated' action from the message to the inline function. \n\nThis then adds that new PR to an array of PR's. Because VueJS is two-way data-bound, I don't need to go anything to get it to render out.\n\nI also hooked the Pingdom API up in the same way, but this time with a full-screen modal that displayed on-top of the other data when we recieved a \"site down\" notification.\n\n```\n<template>\n    <div class=\"grid-y\" v-bind:class=\"{'grid-frame align-center align-middle': pingdomlist.length == 0 }\">\n\n\n        <transition name=\"popin\">\n            <modal v-if=\"pingdomlist.length\">\n                <div slot=\"header\">\n                </div>\n                <div slot=\"footer\"></div>\n                <transition-group slot=\"body\" name=\"popin\" class=\"grid-x grid-margin-x grid-margin-y\" tag=\"div\">\n                    <div v-if=\"pingdomlist.length <= 6\" v-for=\"item in pingdomlist\" :key=\"item.check_id\" class=\"cell large-12 pingdom-item\" v-bind:id=\"item.check_id\">\n                        <div class=\"grid-x grid-padding-x\" v-bind:class=\"item.current_state\">\n                            <div class=\"cell large-6\">\n                                <h2>{{ item.check_name }}</h2>\n                            </div>\n                            <div class=\"cell large-2\" style=\"text-align: center\">\n                                <h2>{{ getDuration(item.state_changed_utc_time) }}</h2>\n                            </div>\n                            <div class=\"cell large-4 align-centre\" style=\"text-align: center\">\n                                <h2 v-bind:class=\"item.current_state\">{{ item.current_state}}</h2>\n                            </div>\n                        </div>\n                    </div>\n\n                    <div v-if=\"pingdomlist.length > 6\" v-for=\"item in pingdomlist\" :key=\"item.check_id\" class=\"cell large-12 pingdom-item\" v-bind:id=\"item.check_id\">\n                        <div class=\"grid-x grid-padding-x cell large-6\" v-bind:class=\"item.current_state\">\n                            <div class=\"cell large-6\">\n                                <h2>{{ item.check_name }}</h2>\n                            </div>\n                            <div class=\"cell large-2\" style=\"text-align: center\">\n                                <h2>{{ getDuration(item.state_changed_utc_time) }}</h2>\n                            </div>\n                            <div class=\"cell large-4 align-centre\" style=\"text-align: center\">\n                                <h2 v-bind:class=\"item.current_state\">{{ item.current_state}}</h2>\n                            </div>\n                        </div>\n                    </div>\n\n                </transition-group>\n            </modal>\n        </transition>        \n    </div>\n</template>\n\n<script>\n    import modal from './Modal.vue';\n    import moment from 'moment';\n\n    var pingdomlist = [];  \n    var isModalVisible = false;\n    var $that = this;\n\n    export default {\n        name: 'Pingdom',        \n        components: {\n            modal,\n        },\n        methods: {\n            showModal: function() {\n                isModalVisible = true;\n                console.log(\"showModal\");\n            },\n            closeModal: function() {\n                isModalVisible = false;\n            },\n            getDuration: function (start) {\n                var startTime = moment(start);\n                var end = moment();\n                var diff = end.diff(startTime);\n\n                return moment.utc(diff).format(\"HH:mm:ss\");\n            },\n        },\n        data: function () {\n            return {\n                isModalVisible,\n                nodata: \"Waiting for Pingdom Info\",\n                pingdomlist\n            }\n        },\n        props: {\n            webhook: String\n        },\n        created: function() {\n            //var uri = \"ws://rbplayground.azurewebsites.net/ws\";\n            var $this = this;\n            var socket = new FancyWebSocket(this.webhook);            \n            socket.bind('pingdom', function (data) {\n\n                var currentState = data.current_state;\n                var index = pingdomlist.map(item => item.check_id).indexOf(data.check_id);\n\n                switch (currentState) {\n                    case \"UP\":                        \n                        pingdomlist.splice(index, 1);                           \n                        break;\n\n\n                    case \"DOWN\":\n                    case \"UNCONFIRMED_DOWN\":\n                    case \"UNKNOWN\":\n                        if (index < 0) {                            \n                            pingdomlist.push(data);                                                   \n                        }\n\n                        if (index > -1) {\n                            $this.$set(pingdomlist, index, data);\n                        }\n\n                        break;\n                }\n                                \n                isModalVisible = pingdomlist.length > 0 ? true : false;\n\n                console.log(\"pingdomListCount = \", pingdomlist.length);\n                console.log(\"modal visible = \", isModalVisible);\n\n                data = {};\n            });            \n        }\n    }\n</script>\n\n<style scoped>\n    .pingdom-item {\n        \n    }\n\n\n    /*.pingdom-item > .DOWN {\n        border: 5px solid red;\n    }\n\n    .pingdom-item > .UNCONFIRMED {\n        border: 5px solid orange;\n    }*/\n\n    h2.DOWN {\n        color: red;\n    }\n\n    h2.UNCONFIRMED {\n        color: orange;\n    }\n    .popin-enter-active {\n        animation: fadeIn .5s;\n    }\n\n    .popin-leave-active {\n        animation: fadeOut .5s;\n    }\n\n    @keyframes fadeIn {\n        0% {\n            opacity: 0;\n        }\n\n        100% {\n            opacity: 1;\n        }\n    } \n\n    @keyframes fadeOut {\n        0% {\n            opacity: 1;\n        }\n\n        100% {\n            opacity: 0;\n        }\n    } \n\n</style>\n```\n\nThe FE for this was done using Zurb Foundation 6. After I'd completed this, I discovered the CSS Grid, which in hindsight, would have served me better, without having to import css and javascript from a framework. Oh well, next time, CSS Grid all the way!\n\n\n\n*Footnote:*\n\nInitiallty, this was built with having integrations with our internal systems such as Jenkins, SonarQube, Jira etc. We migrated away from those to take advantage of the Azure platform, and their CI/CD solutions, so further modifications were done to hook into the CI/CD pipeline to get build status and deployment updates as well. This worked well for our testing team, who could see when a new component or fix was either building, or had completed for them to test.",
  "excerpt": "Having recently discovered VueJS, I decided to re-think and re-write a wallboard screen to show commits/pull requests, build statuses, and site down notifications using .Net Core, VueJS and Websockets",
  "tags": [
    "c"
  ],
  "headerimg": "/img/blogheaders/wallboard.png"
}